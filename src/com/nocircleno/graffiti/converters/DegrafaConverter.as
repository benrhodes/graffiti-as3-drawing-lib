/**  	Graffiti 3.0*  	______________________________________________________________________*  	www.nocircleno.com/graffiti/*//** 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* 	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* 	OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* 	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* 	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* 	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* 	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* 	OTHER DEALINGS IN THE SOFTWARE.*/package com.nocircleno.graffiti.converters {		import com.nocircleno.graffiti.display.LineObject;	import flash.display.GraphicsPathCommand;	import com.nocircleno.graffiti.display.BrushObject;	import com.nocircleno.graffiti.display.GraffitiObject;	import com.nocircleno.graffiti.display.ShapeObject;	import com.nocircleno.graffiti.display.TextObject;	import com.nocircleno.graffiti.tools.*;	import com.nocircleno.graffiti.utils.Conversions;	import flash.events.Event;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.text.Font;	import flash.text.FontType;	import flash.text.FontStyle;	import flash.text.TextFormat;		/**	* The DegrafaConverter Class lets you translate objects drawn with the Graffiti Library to Degrafa markup and back.	*	* @langversion 3.0    * @playerversion Flash 10 AIR 1.5	*/	public class DegrafaConverter {				public function DegrafaConverter() { }				/**		* The <code>from</code> method take defrafa xml data and convert it into a list of GraffitiObjects.		*		* @param degrafaXML Degrafa XML		*		* @return Returns a list of Graffiti Objects.		*/		public static function from(degrafaXML:XML):Vector.<GraffitiObject> {						var objectList:Vector.<GraffitiObject> = new Vector.<GraffitiObject>();						// create graffiti objects from geometry			var objs:XMLList = degrafaXML.GeometryGroup;			var numberObjects:int = objs.length();						var bObject:BrushObject;			var sObject:ShapeObject;			var tObject:TextObject;			var lObject:LineObject;						var color:int;			var hexColor:String;			var size:Number;			var alpha:Number;			var objID:String;			var styleTag:String;			var i:int;			var j:int;			var k:int;						var commands:Vector.<int>;			var drawingData:Vector.<Number>;						var dataSplit:Array;			var dataLength:int;			var positionSplit:Array;						for (i = 0; i < numberObjects; ++i) {								objID = objs[i].@id;								commands = new Vector.<int>();				drawingData = new Vector.<Number>();								if (objID.indexOf("brush") != -1) {										var brushType:String = objID.split("_")[1];										if (brushType == BrushType.ROUND) {												styleTag = objs[i].Path.@stroke;						styleTag = styleTag.substring(1, styleTag.length - 1);												hexColor = degrafaXML.strokes.SolidStroke.(@id == styleTag).@color;						color = int(hexColor.replace(/#/, "0x"));						alpha = Number(degrafaXML.strokes.SolidStroke.(@id == styleTag).@alpha);						size = Number(degrafaXML.strokes.SolidStroke.(@id == styleTag).@weight);										} else {												styleTag = objs[i].Path.@fill;						styleTag = styleTag.substring(1, styleTag.length - 1);												hexColor = degrafaXML.fills.SolidFill.(@id == styleTag).@color;						color = int(hexColor.replace(/#/, "0x"));						alpha = Number(degrafaXML.fills.SolidFill.(@id == styleTag).@alpha);						size = 8;										}										dataSplit = objs[i].Path.@data.split(" ");					dataLength = dataSplit.length;										for (j = 0; j < dataLength; ++j) {												if (dataSplit[j] == "M") {													commands.push(GraphicsPathCommand.MOVE_TO);														positionSplit = dataSplit[j + 1].split(",");														drawingData.push(Number(positionSplit[0]));							drawingData.push(Number(positionSplit[1]));														j++;													} else if (dataSplit[j] == "L") {														commands.push(GraphicsPathCommand.LINE_TO);														positionSplit = dataSplit[j + 1].split(",");														drawingData.push(Number(positionSplit[0]));							drawingData.push(Number(positionSplit[1]));														j++;													}											}										bObject = new BrushObject(new BrushDefinition(brushType, color, alpha, size, 0, commands, drawingData, new Point(Number(objs[i].@x), Number(objs[i].@y))));					bObject.x = Number(objs[i].@x);					bObject.y = Number(objs[i].@y);										objectList.push(bObject);									} else if (objID.indexOf("line") != -1) {										var lineType:String = objID.split("_")[1];										styleTag = objs[i].Path.@stroke;					styleTag = styleTag.substring(1, styleTag.length - 1);											hexColor = degrafaXML.strokes.SolidStroke.(@id == styleTag).@color;					color = int(hexColor.replace(/#/, "0x"));					alpha = Number(degrafaXML.strokes.SolidStroke.(@id == styleTag).@alpha);					size = Number(degrafaXML.strokes.SolidStroke.(@id == styleTag).@weight);										dataSplit = objs[i].Path.@data.split(" ");					dataLength = dataSplit.length;									for (j = 0; j < dataLength; ++j) {												if (dataSplit[j] == "M") {													commands.push(GraphicsPathCommand.MOVE_TO);														positionSplit = dataSplit[j + 1].split(",");														drawingData.push(Number(positionSplit[0]));							drawingData.push(Number(positionSplit[1]));														j++;													} else if (dataSplit[j] == "L") {														commands.push(GraphicsPathCommand.LINE_TO);														positionSplit = dataSplit[j + 1].split(",");														drawingData.push(Number(positionSplit[0]));							drawingData.push(Number(positionSplit[1]));														j++;													} else if (dataSplit[j] == "C") {														commands.push(GraphicsPathCommand.CURVE_TO);														positionSplit = dataSplit[j + 1].split(",");														drawingData.push(Number(positionSplit[0]));							drawingData.push(Number(positionSplit[1]));							drawingData.push(Number(positionSplit[2]));							drawingData.push(Number(positionSplit[3]));														j++;													}											}										lObject = new LineObject(new LineDefinition(lineType, color, alpha, size, Number(objs[i].Path.@width), Number(objs[i].Path.@height), commands, drawingData, new Point(Number(objs[i].@x), Number(objs[i].@y))));					lObject.x = Number(objs[i].@x);					lObject.y = Number(objs[i].@y);										objectList.push(lObject);									} else if (objID.indexOf("shape") != -1) {										var shapeType:String = objID.split("_")[1];										var fillColor:int;					var fillAlpha:Number;					var strokeColor:int;					var strokeAlpha:Number;					var strokeSize:Number;					var fillStyleID:String;					var strokeStyleID:String;					var shapeWidth:Number;					var shapeHeight:Number;										if (shapeType == ShapeType.CIRCLE || shapeType == ShapeType.OVAL) {												strokeStyleID = objs[i].Ellipse.@stroke;						fillStyleID = objs[i].Ellipse.@fill;												var controlAngleRadians:Number;						var anchorAngleRadians:Number;						var xControl:Number;						var yControl:Number;						var xAnchor:Number;						var yAnchor:Number;												shapeWidth = Number(objs[i].Ellipse.@width);						shapeHeight = Number(objs[i].Ellipse.@height);												var theta:int = 45;						var r:Number = Number(objs[i].Ellipse.@width)/2;						var r2:Number = Number(objs[i].Ellipse.@height)/2;												var d:Number = r/Math.cos(Conversions.radians(0.5*theta));						var d2:Number = r2/Math.cos(Conversions.radians(0.5*theta));												var centerPoint:Point = new Point(r, r2);												commands.push(GraphicsPathCommand.MOVE_TO);						drawingData.push(centerPoint.x + r);						drawingData.push(centerPoint.y);															// draw the new preview circle						for(k=(theta/2); k<361; k=k+theta) {														controlAngleRadians = Conversions.radians(k);							anchorAngleRadians = Conversions.radians(k+(theta/2));														xControl = d*Math.cos(controlAngleRadians);							yControl = d2*Math.sin(controlAngleRadians);							xAnchor = r*Math.cos(anchorAngleRadians);							yAnchor = r2*Math.sin(anchorAngleRadians);														commands.push(GraphicsPathCommand.CURVE_TO);							drawingData.push(centerPoint.x + xControl);							drawingData.push(centerPoint.y + yControl);							drawingData.push(centerPoint.x + xAnchor);							drawingData.push(centerPoint.y + yAnchor);												}											} else if (shapeType == ShapeType.RECTANGLE || shapeType == ShapeType.SQUARE) {												strokeStyleID = objs[i].RegularRectangle.@stroke;						fillStyleID = objs[i].RegularRectangle.@fill;												shapeWidth = Number(objs[i].RegularRectangle.@width);						shapeHeight = Number(objs[i].RegularRectangle.@height);												commands.push(GraphicsPathCommand.LINE_TO);						drawingData.push(Number(objs[i].RegularRectangle.@width));						drawingData.push(0);												commands.push(GraphicsPathCommand.LINE_TO);						drawingData.push(Number(objs[i].RegularRectangle.@width));						drawingData.push(Number(objs[i].RegularRectangle.@height));												commands.push(GraphicsPathCommand.LINE_TO);						drawingData.push(0);						drawingData.push(Number(objs[i].RegularRectangle.@height));												commands.push(GraphicsPathCommand.LINE_TO);						drawingData.push(0);						drawingData.push(0);											}										// create stroke properties from xml					if(strokeStyleID != "") {											strokeStyleID = strokeStyleID.substring(1, strokeStyleID.length - 1);											hexColor = degrafaXML.strokes.SolidStroke.(@id == strokeStyleID).@color;						strokeColor = int(hexColor.replace(/#/, "0x"));						strokeAlpha = Number(degrafaXML.strokes.SolidStroke.(@id == strokeStyleID).@alpha);						strokeSize = Number(degrafaXML.strokes.SolidStroke.(@id == strokeStyleID).@weight);										} else {												strokeColor = -1;						strokeAlpha = 1;						strokeSize = 8;											}										// create fill properties from xml					if (fillStyleID != "") {												fillStyleID = fillStyleID.substring(1, fillStyleID.length - 1);												hexColor =  degrafaXML.fills.SolidFill.(@id == fillStyleID).@color;						fillColor = int(hexColor.replace(/#/, "0x"));						fillAlpha = Number(degrafaXML.fills.SolidFill.(@id == fillStyleID).@alpha);											} else {												fillColor = -1;						fillAlpha = 0;											}										sObject = new ShapeObject(new ShapeDefinition(shapeType, strokeColor, fillColor, strokeAlpha, fillAlpha, strokeSize, shapeWidth, shapeHeight, commands, drawingData, new Point(Number(objs[i].@x), Number(objs[i].@y))));					sObject.x = Number(objs[i].@x);					sObject.y = Number(objs[i].@y);										objectList.push(sObject);									}							}						///////////////////////////////////////////////////////////			// Create graffiti objects from text			///////////////////////////////////////////////////////////			var textObjs:XMLList = degrafaXML.RasterText;			numberObjects = textObjs.length();						for (i = 0; i < numberObjects; ++i) {								/*				objectXML = <RasterText color={hexColor} inheritFill="false" inheritStroke="false"									embedFonts={embedFonts} autoSizeField="true"									text = {escape(tObject.text)} fontFamily = {fontName}									fontWeight = {fontWeight} backgroundColor = {bgColor}									fontSize={String(tObject.textSetting.textFormat.size)} borderColor={borderColor} x={String(tObject.x)} y={String(tObject.y)} >								</RasterText>;				*/								var embedFonts:Boolean = textObjs[i].@embedFonts == "true" ? true : false;				var font:Font;				var fontName:String = textObjs[i].@fontFamily;				var fontList:Array = Font.enumerateFonts(!embedFonts);				var numberFonts:int = fontList.length;								for( j=0; j<numberFonts; ++j )				{					if(fontList[j].fontName == fontName) {						font = Font(fontList[j]);						break;					}				}								if(font == null) {					font = Font(fontList[0]);				}								var bgColor:String = textObjs[i].@backgroundColor;				var borderColor:String = textObjs[i].@borderColor;				var textColor:String = textObjs[i].@color;								if (bgColor != "#-1") {					bgColor = bgColor.replace(/#/, "0x");				} else {					bgColor = "-1";				}								if (borderColor != "#-1") {					borderColor = borderColor.replace(/#/, "0x");				} else {					borderColor = "-1";				}								textColor = textColor.replace(/#/, "0x");								var fmt:TextFormat = new TextFormat();				fmt.font = fontName;				fmt.color = int(textColor);				fmt.size = int(textObjs[i].@fontSize);				fmt.bold = textObjs[i].@fontWeight == "bold" ? true : false;								var ts:TextSettings = new TextSettings(font, fmt, int(bgColor), int(borderColor));								tObject = new TextObject(ts);				tObject.text = unescape(textObjs[i].@text);				tObject.x = Number(textObjs[i].@x);				tObject.y = Number(textObjs[i].@y);								var insertPosition:int = int(textObjs[i].@id.split("_")[1]);								if (insertPosition >= objectList.length) {					objectList.push(tObject);				} else {					objectList.splice(insertPosition, 0, tObject);				}							}						return objectList;					}				/**		* The <code>to</code> method converts all Graffiti Objects into degrafa xml.		*		* @param graffitiObjectList A list of GraffitiObjects.		*		* @return Returns an xml object.		*/		public static function to(graffitiObjectList:Vector.<GraffitiObject>):XML {						var i:int;			var j:int;						var objectXML:XML;			var degrafaXML:XML = <Surface>									<fills></fills>									<strokes></strokes>								</Surface>;						var numberObjects:int = graffitiObjectList.length;			var gObject:GraffitiObject;			var bObject:BrushObject;			var sObject:ShapeObject;			var lObject:LineObject;			var tObject:TextObject;			var color:int;			var alpha:Number;			var size:Number;			var strokeID:String;			var fillID:String;			var objectID:String;			var pathData:String;			var numberOfDataPoint:int;						for (i = 0; i < numberObjects; ++i) {								gObject = graffitiObjectList[i];							if (gObject is BrushObject) {										bObject = BrushObject(gObject);										// get properties					color = bObject.brushDefinition.color;					alpha = bObject.brushDefinition.alpha;					size = bObject.brushDefinition.size;										// create object id from brush type and count					objectID = "brush_" + bObject.brushDefinition.type + "_" + i;											// get path data					pathData = convertDrawingCommandsToPath(bObject.brushDefinition.commands, bObject.brushDefinition.drawingData);										if (bObject.brushDefinition.type == BrushType.ROUND) {												// get stroke id						strokeID = getStrokeID(degrafaXML, color, alpha, size);												objectXML = <GeometryGroup id={objectID} x={bObject.x} y={bObject.y}>										<Path stroke={strokeID} data={pathData}></Path></GeometryGroup>;											} else {												fillID = getFillID(degrafaXML, color, alpha);												objectXML = <GeometryGroup id={objectID} x={bObject.x} y={bObject.y}>										<Path fill={fillID} data={pathData}></Path></GeometryGroup>;											}										// add object to xml					degrafaXML.appendChild(objectXML);									} else if (gObject is ShapeObject) {										sObject = ShapeObject(gObject);										// get fill id					if (sObject.shapeDefinition.fillColor != -1) {						fillID = getFillID(degrafaXML, sObject.shapeDefinition.fillColor, sObject.shapeDefinition.fillAlpha);					} else {						fillID = null;					}										// get stroke id					if (sObject.shapeDefinition.strokeColor != -1) {						strokeID = getStrokeID(degrafaXML, sObject.shapeDefinition.strokeColor, sObject.shapeDefinition.strokeAlpha, sObject.shapeDefinition.strokeSize);					} else {						strokeID = null;					}										// create object id from brush type and count					objectID = "shape_" + sObject.shapeDefinition.type + "_" + i;										if (sObject.shapeDefinition.type == ShapeType.OVAL || sObject.shapeDefinition.type == ShapeType.CIRCLE) {												if(fillID == null) {													objectXML = <GeometryGroup id={objectID} x={String(sObject.x)} y={String(sObject.y)}>											<Ellipse stroke={strokeID} height={String(sObject.shapeDefinition.height)} width={String(sObject.shapeDefinition.width)}/>										</GeometryGroup>;																} else if(strokeID == null) {														objectXML = <GeometryGroup id={objectID} x={String(sObject.x)} y={String(sObject.y)}>											<Ellipse fill={fillID} height={String(sObject.shapeDefinition.height)} width={String(sObject.shapeDefinition.width)}/>										</GeometryGroup>;													} else {														objectXML = <GeometryGroup id={objectID} x={String(sObject.x)} y={String(sObject.y)}>											<Ellipse stroke={strokeID} fill={fillID} height={String(sObject.shapeDefinition.height)} width={String(sObject.shapeDefinition.width)}/>										</GeometryGroup>;													}											} else if (sObject.shapeDefinition.type == ShapeType.RECTANGLE || sObject.shapeDefinition.type == ShapeType.SQUARE) {												if(fillID == null) {													objectXML = <GeometryGroup id={objectID} x={String(sObject.x)} y={String(sObject.y)}>											<RegularRectangle stroke={strokeID} height={String(sObject.shapeDefinition.height)} width={String(sObject.shapeDefinition.width)}/>										</GeometryGroup>;																} else if(strokeID == null) {														objectXML = <GeometryGroup id={objectID} x={String(sObject.x)} y={String(sObject.y)}>											<RegularRectangle fill={fillID} height={String(sObject.shapeDefinition.height)} width={String(sObject.shapeDefinition.width)}/>										</GeometryGroup>;													} else {														objectXML = <GeometryGroup id={objectID} x={String(sObject.x)} y={String(sObject.y)}>											<RegularRectangle stroke={strokeID} fill={fillID} height={String(sObject.shapeDefinition.height)} width={String(sObject.shapeDefinition.width)}/>										</GeometryGroup>;													}											}										// add object to xml					degrafaXML.appendChild(objectXML);									} else if (gObject is LineObject) {										lObject = LineObject(gObject);										// get stroke id					strokeID = getStrokeID(degrafaXML, lObject.lineDefinition.strokeColor, lObject.lineDefinition.strokeAlpha, lObject.lineDefinition.strokeSize);										// create object id from brush type and count					objectID = "line_" + lObject.lineDefinition.type + "_" + i;											// get path data					pathData = convertDrawingCommandsToPath(lObject.lineDefinition.commands, lObject.lineDefinition.drawingData);										objectXML = <GeometryGroup id={objectID} x={lObject.x} y={lObject.y}>									<Path stroke={strokeID} width={lObject.lineDefinition.width} height={lObject.lineDefinition.height} data={pathData}></Path></GeometryGroup>;											// add object to xml					degrafaXML.appendChild(objectXML);													} else if (gObject is TextObject) {										tObject = TextObject(gObject);										var hexColor:String = "#" + tObject.textSetting.textFormat.color.toString(16);					var embedFonts:String = tObject.textSetting.embeddedFont ? "true" : "false";					var fontName:String = tObject.textSetting.font.fontName;					var fontWeight:String = tObject.textSetting.textFormat.bold ? "bold" : "normal";					var bgColor:String = "#" + tObject.textSetting.backgroundColor.toString(16);					var borderColor:String = "#" + tObject.textSetting.borderColor.toString(16);										// create object id from brush type and count					objectID = "text_" + i;										objectXML = <RasterText id={objectID} color={hexColor} inheritFill="false" inheritStroke="false"									embedFonts={embedFonts} autoSizeField="true"									text = {escape(tObject.text)} fontFamily = {fontName}									fontWeight = {fontWeight} backgroundColor = {bgColor}									fontSize={String(tObject.textSetting.textFormat.size)} borderColor={borderColor} x={String(tObject.x)} y={String(tObject.y)} >								</RasterText>;													// add object to xml					degrafaXML.appendChild(objectXML);									}							}						return degrafaXML;					}				private static function convertDrawingCommandsToPath(commands:Vector.<int>, data:Vector.<Number>):String {						var pathData:String = "";						// Convert Commands and Data to text string for degrafa output			var numberOfDataPoint:int = commands.length;						var dataCount:int = 0;						var padding:String = "";						for (var i:int = 0; i < numberOfDataPoint; ++i) {								if (i > 0 ) {					padding = " ";				}								if (commands[i] == GraphicsPathCommand.MOVE_TO) {										pathData += padding + "M " + data[dataCount] + "," + data[dataCount + 1];					dataCount += 2;									} else if (commands[i] == GraphicsPathCommand.LINE_TO) {										pathData += padding + "L " + data[dataCount] + "," + data[dataCount + 1];					dataCount += 2;									} else if (commands[i] == GraphicsPathCommand.CURVE_TO) {										pathData += padding + "C " + data[dataCount] + "," + data[dataCount + 1] + "," + data[dataCount + 2] + "," + data[dataCount + 3];					dataCount += 4;									}							}						pathData += " z";						return pathData;					}				private static function getFillID(xml:XML, color:int, alpha:Number):String {						var fillID:String;			var hexColor:String = "#" + color.toString(16);			var fillList:XMLList = xml.fills.children();						//////////////////////////////////////////////////////////			// Create or find Stoke entry			//////////////////////////////////////////////////////////			if (fillList.length() > 0) {								fillID = xml.fills.SolidFill.(@color == hexColor && @alpha == alpha).@id;								// insert new fill tag				if (fillID == "") {										fillID = "gFill_" + fillList.length();					xml.fills.appendChild(<SolidFill id={fillID} color={hexColor} alpha={alpha}/>);									}							} else {								fillID = "gFill_0";				xml.fills.appendChild(<SolidFill id={fillID} color={hexColor} alpha={alpha}/>);							}						return "{" + fillID + "}";					}				private static function getStrokeID(xml:XML, color:int, alpha:Number, size:Number):String {						var strokeID:String;			var hexColor:String = "#" + color.toString(16);			var strokeList:XMLList = xml.strokes.children();						//////////////////////////////////////////////////////////			// Create or find Stoke entry			//////////////////////////////////////////////////////////			if (strokeList.length() > 0) {								strokeID = xml.strokes.SolidStroke.(@color == hexColor && @alpha == alpha && @weight == size).@id;								// insert new stroke tag				if (strokeID == "") {										strokeID = "gStroke_" + strokeList.length();					xml.strokes.appendChild(<SolidStroke id={strokeID} color={hexColor} weight={size} alpha={alpha}/>);									}							} else {								strokeID = "gStroke_0";				xml.strokes.appendChild(<SolidStroke id={strokeID} color={hexColor} weight={size} alpha={alpha}/>);							}						return "{" + strokeID + "}";					}			}		}